---

title: JVM
author: Wang Yue Niao
top: false
toc: true
date: 2020-09-13 19:49:08
tags: JVM
categories: JVM
---

## JVM整体结构

![](https://s3.jpg.cm/2020/09/13/HPBqw.png)

##### JVM的生命周期

###### JVM的启动

​    java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。

###### JVM的执行

- 一个运行中的java虚拟机有着一个清晰的任务：执行java程序
- 程序开始执行时他才运行，程序结束时它就停止。
- 执行一个所谓的java程序的时候，真真正正在执行的是一个叫做java虚拟机的进行

###### JVM的退出

   有如下几种情况：

         1. 程序正常执行结束
            2. 程序在执行过程中遇到了异常或错误而异常终止
            3. 由于操作系统出现错误而导致java虚拟机进程终止
            4. 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。
            5. 除此之外，JNI (Java Native Interface)规范描述了用JNI Invocation API来加载或卸载java虚拟机时，java虚拟机的退出情况。

## 类加载子系统

![](https://s3.jpg.cm/2020/09/15/Hdxmh.png)

### 类加载阶段

类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。

![](https://s3.jpg.cm/2020/09/15/HdDTS.png)

#### 1、加载

将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。



#### 2、链接

将Java类的二进制代码合并到JVM的运行状态之中。
 **• 验证**
 确保加载的类信息符合JVM规范，没有安全方面的问题。
 **• 准备**
 正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。
 **• 解析**
 虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。



#### 3、初始化

初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的**赋值**动作和**静态语句块(static块)**中的语句合并产生的。

- 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。

### 类加载器原理

#### 1、类缓存

标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。

#### 2、类加载器的分类

![](https://s3.jpg.cm/2020/09/15/HdOdW.png)

**引导类加载器（bootstrap class loader）**
 （1）它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。
 （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。

**扩展类加载器（extensions class loader）**
 （1）用来加载 Java 的扩展库(JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容)x 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
 （2）由sun.misc.Launcher$ExtClassLoader实现。

**应用程序类加载器（application class loader）**
 （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
 （2）由sun.misc.Launcher$AppClassLoader实现。

**自定义类加载器**
 （1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。

#### 3、java.class.ClassLoader类

**（1）作用：**

- java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。
- ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。

**(2)常用方法：**

- getParent() 返回该类加载器的父类加载器。
- loadClass(String name) 加载名称为 name的类，返回的结果是java.lang.Class类的实例。
   **此方法负责加载指定名字的类，首先会从已加载的类中去寻找，如果没有找到；从parent ClassLoader[ExtClassLoader]中加载；如果没有加载到，则从Bootstrap ClassLoader中尝试加载(findBootstrapClassOrNull方法), 如果还是加载失败，则自己加载。如果还不能加载，则抛出异常ClassNotFoundException。**
   - findClass(String name) 查找名称为 name的类，返回的结果是java.lang.Class类的实例。
- findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。
- defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是java.lang.Class类的实例。这个方法被声明为 final的。
- resolveClass(Class<?> c) 链接指定的 Java 类。

### 双亲委派机制

工作原理：

1. 如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。
2. 如果父类加载器还存在其他父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。
3. 如果父类加载器可以完成加载任务，就成功返回，若父类加载器无法完成此加载任务，子加载器才会尝试自己去加，这就是双亲委派模式

![](https://s3.jpg.cm/2020/09/15/HeLqL.png)

## 运行时数据区概述及线程

##### JVM运行时数据区

- 线程私有的数据区
  1. 程序计数器
  2. 虚拟机栈
  3. 本地方法栈
- 所有线程共有的数据区
  1. java堆
  2. 方法区

![](https://s3.jpg.cm/2020/09/16/HAmYu.png)

![](https://s3.jpg.cm/2020/09/16/HAo1X.png)

-----------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------------



![](https://s3.jpg.cm/2020/09/16/HAETR.png)





## 程序计数器(PC寄存器)

#### 作用

记录当前线程所执行到的字节码的行号。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

#### 意义

JVM的多线程是通过线程轮流切换并分配处理器来实现的，对于我们来说的并行事实上一个处理器也只会执行一条线程中的指令。所以，为了保证各线程指令的安全顺利执行，每条线程都有独立的私有的程序计数器。

#### 存储内容

当线程中执行的是一个Java方法时，程序计数器中记录的是正在执行的线程的虚拟机字节码指令的地址。 
当线程中执行的是一个本地方法时，程序计数器中的值为空。

#### 可能出现的异常

此内存区域是唯一一个在JVM上不会发生内存溢出异常（OutOfMemoryError）的区域。

#### 两个常见问题

1. **使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？**

​           因为CPU需要不停切换各个线程，这时候切换回来以后，就得知道线程接着从哪开始继续执行。

2. **PC寄存器为什么会被设定为线程私有？**

   ​     多线程在一个待定的时间内只会执行其中某一线程的方法，CPU会不停的做任务切换，这样必然导致经常中断或恢复。

   ​      为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器。

![](https://s3.jpg.cm/2020/09/16/HA4BD.png)

![](https://s3.jpg.cm/2020/09/16/HAgA6.png)



## 虚拟机栈

觉得这篇文章总结的很到位---------》[传送门](https://www.cnblogs.com/newAndHui/p/11168791.html)

### 虚拟机栈的概述

- Java 虚拟机栈（Java Virtual Machine Stacks）是**线程私有**的，生命周期随着线程启动而产生，线程结束而消亡。
- Java 虚拟机栈描述的是 Java 方法执行的内存模型，用于**存储栈帧**。线程启动时会创建虚拟机栈，每个方法在执行时会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法返回地址、附加信息等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈（压栈）到出栈（弹栈）的过程。
- Java 虚拟机栈使用的内存不需要保证是连续的。
- Java 虚拟机规范即允许 Java 虚拟机栈被实现成固定大小（`-Xss`），也允许**通过计算结果动态来扩容和收缩大小**。如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候就已经确定。

### 栈帧的概念

​    栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

#### 局部变量表

- 局部变量表也被称之为局部变量数组或本地变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量

- 由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题

- 局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的数据项中。在方法运行期间是不会改变局部变量表的大小的。

  

- 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，是的局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

- 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后随着方法栈帧的销毁，局部变量也会随之销毁。

#### 操作数栈

- 操作数栈，主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间。

- 操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。

- 操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。

- 当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

#### 动态链接

- 每一个栈帧内都包含一个指向**运行时常量池**中**该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现**动态链接**。

- 在java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法是，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

#### 方法返回地址

- 存放该方法的pc寄存器的值
- 一个方法的结束，有两种方式：
  1. 正常执行完成
  2. 出现未处理的异常，非正常退出
- 无论通过那种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。而通过异常推出的，返回地址是要通过异常表确定，栈帧中一般不会保存这部分信息。
- 正常完成出口和异常完成出口的区别在于：通过异常完成出口的退出的不会给他的上层调用者产生任何的返回值。

#### 附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。

### 虚拟机栈的面试题

1. 举例栈溢出的情况？（StackOverflowError）
2. 调整栈大小，就能保证不出现溢出吗？
3. 分配的栈内存越大越好嘛？
4. 垃圾回收是否会涉及到虚拟机栈？
5. 方法定义的局部变量是否线程安全？

## 本地方法接口 

##### 什么是本地方法？

- 简单的讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java方法：该方法的实现由非java语言实现，比如C。这个特征并非java特有，很多其他的编程语言都有这一机制。

- 在定义一个native methopd时，并不提供实现体(有些像定义一个java interface)，因为实现实现体是由非java语言在外面实现的。
- 本地接口的作用是融合不同编程语言为java所有，它的初衷是融合c/c++程序。

## 本地方法栈

##### 本地方法栈概述

- 对于一个运行中的Java程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。
- 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。
- 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。
- java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法做的调用
- 本地方法栈，也是线程私有的
- 允许被实现成固定或者是课动态扩展的内存大小（在内存溢出方面是相同的）
- 本地方法是使用c语言实现的
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库

## 堆

### 堆的核心概述

- 一个JVM实例只存在一个堆内存，对也是java内存管理的核心区域
- java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JJVM管理的最大的一块内存空间（堆的内存大小是可以调节的）
- 《java虚拟机规范》规定，对可以处于物理上不连续的内训空间中，但在逻辑上他应该被视为连续的。
- 所有的线程共享java堆，在这里还可以划分线程私有的缓冲区
- 《java虚拟机规范》中对java堆中的描述是：所有的对象是咧以及数组都应当在运行时分配在堆上。
- 数组和对象永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在队中的位置。
- 在方法结束后，堆中的对象不会马上被移除，隐隐在垃圾收集的时候才会被移除。
- 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域

![](https://s3.jpg.cm/2020/09/18/HYQC5.png)

### 设置堆内存大小与OOM

- java堆用于存储java实例对象，那么堆的大小在JVM启动时就已经设定好了，可以通过选项“-Xmx”和“Xms”来进行设置。

  1. “-Xmx”用于表示堆的起始内存
  2. “Xmx”用于表示堆区最大内存

- 一旦堆区中内存大小超过“-Xmx”所指定最大内存时，将会抛出OutOfMeoryError异常。

- 通常会将“-Xmx”和“Xms”两个参数配置相同的值，其目的为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。

- 默认情况下，初始内存大小：物理电脑内存大小/64

  ​                        最大内存大小：物理内存大小/64

### 年轻代与老年代

- 存储在JVM中的对象可以被划分为两类：
  1. 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。
  2. 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代和老年代
- 其中年轻代又可以划分为Eden，Survivor0和Survivor1空间（有时也叫from区，to区）
- 几乎所有的java对象都是在Eden区被new出来的
- 绝大部分对象的销毁都在新生代进行了

### 图解对象分配过程

![](https://s3.jpg.cm/2020/09/21/H4MCz.png)

1. new的对象先放在Eden区，此区有大小限制。
2. 当Eden区的空间填满时，程序又需要创建对象，JVM垃圾回收器将对Eden区进行垃圾回收，将Eden区中不再被其他对象所引用的对象进行销毁，在加载新的对象到Eden区。
3. 然后将Eden区中的剩余对象移动到幸存者0区。
4. 如果再次出发垃圾回收，此时上次幸存下来的的放在幸存者0区的，如果没有回收，就会到到幸存者1区。
5. 如果再次经历垃圾回收，此时又会方法哦幸存者0区，接着再去幸存者1区。
6. 啥时候能去养老区呢？可以设置次数。默认是15次。

总结：

- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。
- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。

### Minor GC、Major GC、Full GC

- JVM在进行GC时，	并非每次都对上面三个内存区域一起回收的（新生代，老年代；方法区），大部分时候都是指新生代。

- 针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（partial GC）,一种是整堆收集（Full GC）

  1. 部分收集：不是完整收集整个java对的垃圾收集。其中又分为：
     - 新生代收集（Minor GC / Young GC）:只是新生代的垃圾收集器
     - 老年代收集（Major GC / Old  GC）:只是老年代的垃圾收集
       - 目前只有CMS GC会有单独收集老年代的行为
       - **注意**，很多时候Major GC和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
     - 混合收集：收集整个新生代以及部分老年代的垃圾收集。
       - 目前，只有G1,GC会有这种行为
  2. 整堆收集（Full GC）:收集整个java堆和方法区的垃圾收集。

  

  **年轻代GC（Minor GC）触发机制：**

  - 当代年代空间不足时，就会触发Minor GC,这里年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）
  - 因为java对象大多都是具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义即清晰又易于理解
  - Minor GC 会引发STW,暂停其他用户的线程，等垃圾回收结束，用户线程才会恢复运行。

  **老年代GC（Major GC / Full GC）触发机制：**

  - 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了 
  - 出现了Major GC，经常会伴随至少一次的Minor GC (但绝对的，在Parallel Scavenge收集器的收集策略里就直接进行Major GC的策略选择过程)
  - Major GC的速度一般会比Minor GC慢10倍以上，STW时间更长
  - 如果Major GC后，内存还不足，就报OOM了

  **Full GC触发机制：**

  - 触发Full GC执行的情况有如下五种

    1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行

    2. 老年代空间不足

    3. 方法区空间不足

    4. 通过Minor GC 后进入老年代的平均大小大于老年代的可用内存

    5. 有Eden区，survior space0(From Space)区像survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年带，且老年代的可用内存小于该对象大小

       **Full GC是开发中调优中尽量要避免的，这样暂时时间会短一些**

  ![](https://s3.jpg.cm/2020/09/21/HB5dT.png)

### 堆空间分代思想

 为什么需要把java堆分代？不分代就不能正常工作了嘛？

- 经研究，不同对象的生命周期不同。70%-99%的对象时临时对象
  - 新生代：有Eden，两块大小相同的Survivor（又称为from/to,so/s1）构成，to总为空。
  - 老年代：存放新生代中经历多 次GC仍然存活的对象

![](https://s3.jpg.cm/2020/09/21/HBQKQ.png)

![](https://s3.jpg.cm/2020/09/21/HBeqh.png)

### 内存分配策略

![](https://s3.jpg.cm/2020/09/21/HBlHS.png)

![](https://s3.jpg.cm/2020/09/21/HB6gW.png)

### 为对象分配内存：TLAB

**为什么要有TLAB（Thread Local Allocation Buffer）？**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**什么是TLAB?**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。

- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略
- 据我所知所有的OpenJDK衍生出来的JVM都提供了TLAB的设计

**TLAB的在说明**

- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，单JVM确实是将TLAB作为内存分配的首选
- 在程序中，开发人员可以通过选项“-XX：UseTLAB”设置是否开启TLAB空间
- 默认情况下TLAB空间内存非常小，仅战友整个Eden空间的1%，当然我们可以通过选选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通弄过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

![](https://s3.jpg.cm/2020/09/21/HBcaf.png)

### 小结堆空间的参数设置

![](https://s3.jpg.cm/2020/09/21/H0k4G.png)

![](https://s3.jpg.cm/2020/09/21/H0mD4.png)

### 堆是分配对象存储的唯一选择嘛？

![](https://s3.jpg.cm/2020/09/21/H0B76.png)

![](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20200921231141604.png)

### 逃逸分析代码优化

![](https://s3.jpg.cm/2020/09/21/H034S.png)



## 方法区

### 栈、堆、方法区的交互关系

![](https://s3.jpg.cm/2020/09/23/HxGy8.png)

### 方法区的理解

![](https://s3.jpg.cm/2020/09/23/HxR2e.png)

- 方法区与java堆一样，是各个线程共享的区域
- 方法区在JVM启动的时候被创建，并且它的实际物理内存空间和java堆一样都可以是不连续的
- 方法区的大小，与堆空间一样，可以选择固定大小或者可扩展
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误 java.long.OutOfMemory Error:Metaspace
  - 加载大量的第三方jar包；Tomcat部署工程过多（30-50）个；大量动态的生成反射类
- 关闭JVM就会释放这个区域的内存

### 设置方法区的大小与OOM

- 方法区的大小不是固定的，JVM可以根据引应用动态调整

- jdk7及之前：

  - 通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M。
  - -XX:MaxPermSize来设置永久代最大可分配空间32位机器默认是64M，64位机器模式是82M

- 当JVM类加载信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。

  ![](https://s3.jpg.cm/2020/09/24/HDdfH.png)

### 方法区的内部结构

![](https://s3.jpg.cm/2020/09/24/HD1He.png)

![](https://s3.jpg.cm/2020/09/24/HDHfy.png)

![](https://s3.jpg.cm/2020/09/24/HDJZr.png)

![](https://s3.jpg.cm/2020/09/24/HDNX5.png)

![](https://s3.jpg.cm/2020/09/24/HDSpC.png)

![](https://s3.jpg.cm/2020/09/24/HDYat.png)

### 方法区的垃圾回收

- 很多人以为方法区（或者HotSopt VM中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。

- 永久代的垃圾收集主要回收两部分内容：**废弃常量**和**无用的类**。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。

- 无用的类需要满足3个条件：

​    （1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；
​    （2）加载该类的ClassLoader已经被回收；
​    （3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​         虚拟机可以对满足上述3个条件的无用类进行回收，此处仅仅是“可以”，而并不是和对象一样（不使用了就必然回收）

### 方法区的演变细节

| jdk代数      | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| jdk1.6及以前 | 有永久代（permanent generation）,静态变量存放在永久代        |
| jdk1.7       | 有永久代，但已经逐步”去永久代“，字符串常量池和静态变量移出永久代并放入堆中 |
| jdk1.8及以后 | 无永久代，类型信息、字段、方法和常量保存在**本地内存**的元空间，但是字符串常量池和静态变量仍然在堆中（之前是将永久代使用虚拟机内存，现在是本地内存） |

## 总结面试

![](https://s3.jpg.cm/2020/09/26/J8bfH.png)

面经[传送门](https://blog.csdn.net/luott_777/article/details/108575690)

### 百度

三面：说一下JVM内存模型吧，有哪些分区，分别干什么的？

### 蚂蚁金服

Java8的内存分代改进

JVM 内存分哪几个区，每个区的作用是什么？

一面：内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivior区？

二面：Eden和suivior的比例分配

### 小米

JVM内存分区，为什么要有新生代和老年代

### 字节跳动

二面：Java的内存分区

二面：讲讲jvm运行时数据区

什么时候对象会进入老年代

### 京东

JVM的内存结构，Eden和Survior比例

JVM内存为什么要分成新生代，老年代，持久代。新生代中问什么要分为Eden和Survior

### 天猫

一面：JVM内存模型以及分区，需要详细到每个区放什么

一面：JVM的内存模型，Java8做了什么修改

### 拼多多

JVM内存分哪个几个区，每个区的作用是什么？

### 美团

java内存分配

JVM的永久代中会发生垃圾回收嘛？

一面：JVM内存分区，为什么要有新生代和老年代



## 对象的实例化内存布局与访问定位

![](https://s3.jpg.cm/2020/09/28/J1DFD.png)



![](https://s3.jpg.cm/2020/09/28/JHGNT.png)



![](https://s3.jpg.cm/2020/09/28/JHI2E.png)

## 直接内存

### 直接内存概述

- 不是虚拟机运行时数据区的一部分，也不是《java虚拟机规范》中定义的内存区域
- 直接内存是在java对外的、直接向系统申请的内存区域
- 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
- 通常，访问直接内存的速度会优于java堆。即读写性能高 
  - 因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存
  - java的NIO库允许java程序使用直接内存，用于数据缓冲区
- 也可能导致OutOfMemoryError异常
- 由于直接内存在java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，JAVA堆和直接内存的总和依然受限于操作系统能给出的最大内存。
- 缺点：
  - 分配回收成本高
  - 不收JVM内存回收管理
- 直接内存大小可以通过MaxDirectMenmorySize设置
- 如果不指定，默认与堆的最大值-Xmx参数一致

## 执行引擎

[传送门](https://blog.csdn.net/u012068483/article/details/106848078)

## 垃圾回收概述

### 大厂面试题

![](https://s3.jpg.cm/2020/09/30/JvEnu.png)

![](https://s3.jpg.cm/2020/09/30/JvFtG.png)



### 什么是垃圾

- 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
- 如果不几十对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导出内存溢出

### 为什么需要GC

![](https://s3.jpg.cm/2020/09/30/Jvkz4.png)

### 早期垃圾回收

![](https://s3.jpg.cm/2020/09/30/JvpIX.png)

### Java垃圾回收机制

- 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
- 自动内存管理机制，将程序从繁重的内存管理中释放出来，可以更专心专注于业务开发
- 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区回收，**其种，Java堆是垃圾收集器的工作重点**
- 从次数上讲：
  - 频繁收集Young区
  - 较少收集Old区
  - 基本不动Perm区

### 担忧

- 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将是一场灾难，最严重的的就会弱化Java开发人员在程序出来内存溢出时定位问题和解决问题的能力
- 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题
- 当需要排查各种内存溢出，内存泄漏问题时，当垃圾收集器成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

## 垃圾回收相关算法

### 标记阶段：引用计数算法

- 引用计数算法比较简单，对每一个对象保存一个整型的引用计数器。用于记录对象被引用的情况。
- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1，只要A的引用计数器为的值0，则表示对象A不可能再被使用，可以进行回收。
- 优点：实现简单，垃圾对象便于辨识，判定率高，回收没有延迟性。
- 缺点:
  - 他需要单独的引用计数器，这样的做法增加了存储空间的开销
  - 每次更新都需要更新计数器，伴随加法和减法的操作，这样增加了时间开销。
  - 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命的缺陷，导致在java的垃圾回收器中没有使用这类算法。

### 标记阶段：可达性分析算法（根搜索算法，追踪性垃圾收集）

- 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地**解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。**
- 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪行垃圾收集。
- 基本思路：
  - 可达性分析算法是以根对象集合为起始点按照从上至下的方式搜索被跟对象集合所连接的目标对象是否可达。
  - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链
  - 如果目标对象没有任何引用链相连，则是不可达的，就一文哲该对象已经死亡，可以标记为垃圾对象。
  - 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

### 对象的finalization机制

![](https://s3.jpg.cm/2020/10/03/JjiJD.png)

![](https://s3.jpg.cm/2020/10/03/Jjxzp.png)

![](https://s3.jpg.cm/2020/10/03/JjOcT.png)

### 清除阶段：标记-清除算法

- 执行过程

  当队中有效空间被耗尽的时候，快就停止整个程序，然后进行两项工作，第一项是标记，第二项是清除。

  - 标记：Collector从引用根节点开始遍历，标记所有被引用的度一项。一般是在对象的Header中记录为可达对象。
  - 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

- 缺点：

  - 效率不算高
  - 在进行GC的时候，需要停止整个应用程序，导致用户体验差
  - 这种方式清理出来的空间内存是不连续的，产生内存碎片，需要维护一个空闲列表

- 注意：何为清除？

  - 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新的对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

### 清除阶段：复制算法

- 核心思想：
  - 将活着的内存分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
- 优点：
  - 没有标记和清除过程，实现简单，运行高效
  - 赋值过去以后保证空间的连续性，不会出现“碎片”问题
- 缺点：
  - 此算法的缺点也是很明显的，就是需要两倍的内存空间
  - 对于G1这种分拆为大量region的GC，复制而不是移动，以为着需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。
- 特别的：
  - 如果系统中垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。

### 清除阶段：标记-压缩算法（或标记-整理算法）

- 执行过程：
  - 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象
  - 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有空间。
- 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，在进行yi8ci碎片整理，因此，也可以把它称为标记-清除-压缩算法
- 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并
- 可以看到，标记的存活对象将会被整理，按照内存地址一次排列，而未被标记的及内存会被清理掉，如此一俩，当我们需要给辛对象分配内存时，JVM只需要吃有一个内存的其实地址即可，这比维护一个空闲列表显然少了许多开销存的风险决策
- 优点：
  - 消除了标记清除算法当中，内存区域分散的缺点，我们需要给辛对象分配内存时，JVM只需要持有一个内存的起始地址即可
  - 消除了赋值算法当中，内存减半的高额代价
- 缺点：
  - 从效率上来说，标记-整理算法要低于复制算法。
  - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
  - 移动过程中，需要暂停全用户应用程序。即：STW。

### 分代收集算法

- 目前几乎所有的GC都是采用分代收集算法执行垃圾回收的。
- 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点
- 年轻代
  - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁。
  - 这种情况复制算法的回收整理速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代回收，而复制算法内存利用率不高的问题，通过hospot中的两个survivor设计得到缓解。
- 老年代
  - 老年代特点：区域较大，对象生命周期长，存活率高，回收不及年轻代频繁。
  - 这种情况存在大量存活率高的对象，复制算法明显变的不合适，一般是由标记-清除或者是标记-清除与标记-整理的混合实现。

### 增量收集算法、分区算法

- 增量收集算法
  - 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性为了解决这个问题，即对实时垃圾收集算法的研究部直接导致了增量收集算法的诞生。
  - 基本思想：
    - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一次反复，直到垃圾收集完成。
    - 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
  - 缺点：使用这种方式，由于在垃圾回收过程中，间接性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会是的垃圾回收的总体成本上升，造成系统吐出量的下降。
- 分区算法
  - 一般来书，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长，为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的胡思后若干多个小区间，而不是整个堆空间，从而减少一次GC所产生的的停顿。
  - 分代算法按照对象的生命周期长短划分成两个部分，分区算法将整个对空间划分成连续的不同小区间。
  - 每一个小区间都能独立使用，独立回收。这种算法的好处是可以控制一次回收多个小区间。

## 垃圾回收相关概念

### System.gc()的理解

- 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
- 然后System.gc()调用附带一个免责声明，无法保证垃圾收集器的调用。
- JVM实现着可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过麻烦了，在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。

### 内存溢出与内存泄漏

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



![](https://s3.jpg.cm/2020/10/04/JaGxt.png)



----------------------------------------------------------------------------------------------------------------------------------------------------------





![](https://s3.jpg.cm/2020/10/04/JaL6R.png)





------------------





![](https://s3.jpg.cm/2020/10/04/JaPEz.png)



----------------------



![](https://s3.jpg.cm/2020/10/04/JaRju.png)

-------------------------



### Stop The World

![](https://s3.jpg.cm/2020/10/04/JaAjh.png)

----------------------

 ![](https://s3.jpg.cm/2020/10/04/Jac5S.png)

### 再谈引用

- 强引用：最传统的“引用”的定义，是指在程序代码中普遍存在的引用赋值，即类似“Objecct obj=new Object()”这个指标引用关系。**无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉引用的对象。**
- 软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收、如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例，为一个对象设置虚引用关联的**唯一目的就是能在这个对象被收集器回收时收到一个系统通知**

### 再谈引用：强引用（不回收）

- 在java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，**也是默认的引用类型**
- 当在java语言中使用new操作创建一个新的对象，并将其赋值给你一个变量的时候，这个变量就成为指向该对象的一个强引用
- 强引用的对象时可触及的，垃圾收集器就永远不会回收掉被引用的对象
- 对于一个普通的对象，如果没有其他引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收实际还是要看垃圾收集策略。
- 相对的软引用，弱引用和虚引用的对象时软可触及，若可触及和虚和触及的，在一定条件下，都是可以被回收的。所以，强引用是造成java内存泄漏的主要原因之一。

### 再谈引用：软引用（内存不足即回收）

![](https://s3.jpg.cm/2020/10/04/JaD7h.png)



### 再谈引用：弱引用（发现及回收）

![](https://s3.jpg.cm/2020/10/04/JaMSS.png)



### 再谈引用：虚引用（对象回收跟踪）

![](https://s3.jpg.cm/2020/10/04/JaO3W.png)

![](https://s3.jpg.cm/2020/10/04/JiIuH.png)



### 再谈引用：终结器引用

![](https://s3.jpg.cm/2020/10/04/Jiq8U.png)



## 垃圾回收器 

### 评估GC性能指标

- 吞吐量：运行用户代码的时间占总运行时间的比例
  - （总运行时间：程序的运行时间+内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
- 手机频率：相对于应用程序的执行，收集操作发生的频率
- 内存占用：Java堆区所占用内存大小
- 快速：一个对象从诞生到被回收所经历的时间

### Serial回收器：串行回收

- Serial收集器是最基本，历史最悠久的垃圾收集器了。JDK1.3之前回收新生代的唯一选择
- Serial收集器作为HotSpot中Client模式下默认新生代垃圾收集器
- **Serial收集器采用复制算法，串行回收和“Stop the World”机制的方式执行内存回收**
- 除了年轻代之外，Serial收集器还提供了用于执行老年代的垃圾收集Serial Old收集器。**Serial Old收集器同样采用了串行回收和“Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法**
  - Serial Old是运行在Client模式下默认的老年代垃圾回收器
  - Serial Old在Server模式下主要有两个用途：
    1. 与新生代的Parallel Scavenge配合使用
    2. 作为老年代CMS收集器的后背垃圾收集方案
- 优势：简单高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
  - 运行在Client模式下的虚拟机是个不错的选择
- 在HotSpot虚拟机中，使用 -XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器
  - 等价于新生代用Serial GC ，且老年代用Serial Old GC
- 总结：
  - 这种垃圾收集器大家了解，现在已经不用串行的了，而且在限定单核cpu才可以用。现在都不是单核的了
  - 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用穿行垃圾收集器的

### ParNew回收器：并行回收

- 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本
  - Par是Parallel的缩写，New：只能处理的是新生代
- ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop-the-World”机制
- ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器
- 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？
  - ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量
  - 但是在单个CPU的环境下，ParNew收集器不必Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。
- 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作
- 在程序中，开发人员可以通过选项“-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。
- -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同线程数

### Parallel回收器：吞吐量优先

- HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和“Stop the World”机制
- 那么Parallel收集器的出现是否多此一举
  - 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器
  - 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别
- 高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因为，常见在服务器环境中使用。例如，那些执行批量处理、订单处理，工资支付、科学计算的应用。
- Parllel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parllel Old收集器，用来代替老年代Serial Old收集器。
- Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和“Stop -the-World”机制
- 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，早Server模式下的内存回收性能很不错
- 在Java8中，默认是此垃圾收集器
- 参数配置
  - -XX:+UseParallelGC  手动指定年轻代使用Parallel并行收集器执行内存回收任务
  - -XX:+UseParallelOldGC  手动指定老年代都是使用并行回收收集器
    - 分别适用于新生代和老年代。默认是jdk1.8开启的。
    - 上面两个参数，默认开启一个，另外一个也会被开启。（互相激活）
  - -XX:+UseParallelGCThreads  设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能
    - 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等与CPU数量
    - 当CPU数量大于8个，PrallelGCThreads的值等于3+[5*CPU_Count]/8
  - -XX:+MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒
    - 为了尽可能把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。
    - 对于用户来讲，停顿时间越短越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制
  - -XX:GCTimeRatio 垃圾收集时间占总时间比例(1/(N+1))。用于衡量吞吐量的大小。
    - 取值范围(0,100)。默认值99也就是垃圾回收时间不超过 1%。
    - 与前一个-XX:MaxGCPauseMillis参数有一定行矛盾性。暂停时间越长，Radio参数就容易超过设定的比例
  - -XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略
    - 在这种模式下，年轻代的大小，Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
    - 在手动调优比较困难的场合、可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量和停顿时间，让虚拟机自己完成调优工作。

### CMS回收器：低延迟

- CMS的垃圾收集算法采用标记-清除算法，并且也会“STW”
- 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以JDK1.5中使用CMS来收集老年代的时候，新生代只能选择PaNew或者Serial收集器中的一个
- 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然后很多系统使用CMS GC
- CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。
  - 初始标记阶段：在这个阶段中，程序中所有的工作线程都将会因为“STW"机制而出现短暂的暂停，**这个阶段的主要任务仅仅只是标记处GC Roots能直接关联到的对象。**一旦标记完成之后就会恢复之前被砸你听的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
  - 并发标记阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
  - 重新标记阶段：由于在并发标记阶段中，程序的工作线程回合垃圾收集线程同时运行或者交叉运行，因此为了**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，单页远比并发标记阶段的时间短。
  - 并发清除阶段：此阶段**清理删除标记阶段判断死亡的对象，释放内存空间**。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
- 尽管CMS收集器采用的是并发回收，但是在其**初始化标记和再次标记这两个阶段中仍然需要执行“STW”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“STW”
- 由于最费时间的并发标记与并发清除阶段都不需要暂停工作，座椅整体回收时低停顿的。
- 另外，由于在垃圾收集阶段用户线程没有中断，所以**在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用**。因为，CMS收集器不能想起他收集器那样等到来年代几乎完全被填满在进行收集，而是**当堆内存使用率达到某一阈值时，便开始进行回收**，以确保应用程序在CMS工作过程中依然有足够的空间支持应用运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这是虚拟机将启动后背预案：临时启用Serial Old收集器来重新进行老年代垃圾收集，这样停顿时间就很长了。
- CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在位新对象分匹配内存空间是，将无法使用指针碰撞技术，而只能够选择空闲列表执行内存分配。
- 优点
  - 并发收集
  - 低延迟
- 弊端
  - 会产生内存碎片
  - CMS收集器对CPU资源非常敏感。在并发阶段你，他虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低。CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么**在并发标记阶段如果能产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收**，从而只能在下一次执行 GC时释放这些之前未被回收的内存空间。
- 参数设置
  - -XX:+UseConcMarkweepGC 手动指定使用CMS收集器执行回收任务
    - 开启该参数后悔自动将-XX:+UseParNewGC打开。即：ParNew（young区用）+CMS（Old区用）+Serial Old的组合
  - -XX:CMSLnitiatingOccupanyFraction 设置内存使用率的阈值，一旦达到该阈值，便开始进行回收
    - JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%
    - 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效的降低CMS的触发频率，减少老年代回收次数可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。
  - -XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
  - -XX:CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。
  - -XX:ParallelCMSThreads 设置CMS的线程数量
    - CMS默认启动线程数是（ParallelGCThreads+3）/4，ParalleclGCThreads是年轻代并行收集的线程数，当CPU资源比较紧张时，收到CMS收集器线程的影响，应用程序性能在垃圾回收阶段可能会非常糟糕。

### G1回收器：区域划分代式

- G1是面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同事，还兼备高吞吐量的性能特征。
- 在JDK1.7版本正式启用，溢出了Experimental的标识，是JDK9以后默认垃圾收集器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方成为“全能的垃圾收集器”。
- 与此同时，CMS已经在JDK9中被标记为废弃。在jdk8中还不是默认的垃圾回收器，需要使用-XX:UseG1GC来启用。
- 与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：
  - 并行与并发
    - 并行性：G1再回首时期，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
    - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
  - 分代收集
    - 从分代上看，G1**依然属于分代型垃圾回收器**，他会区分年轻代和老年代，年轻代依然后Eden区和Survivor区。但从堆的结构上看，他不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
    - 将堆空间分为若干区域（Region），这些区域中包含了逻辑上的年轻代和老年代。
    - 和之前的各类回收器不同，他同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；
- 空间整合
  - CMS:"标记-清除"算法、内存碎片、若干次GC后进行一次碎片整理
  - G1将内存划分为一个个的Region。内存的回收是以region作为基本单位的。**Region之间是复制算法**，单整体上实际可看作是**标记-压缩算法**，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。
- 可预测的停顿时间模型
  - 这是G1相对于CMS的另一大优势，G1除了追求地停顿外，还能简历可预测的停顿时间魔心个，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的而时间不得超过N毫秒。
  - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制
  - G1跟踪各个Region里面的垃圾堆积的价值太小，在后台维护一个有限列表，**每次根据允许的收集时间，有优先回收价值最大的Region**。保证了G1收集器在优先的时间内可以**获取尽可能高的收集效率**
  - 相比于CMS GC,G1未必能做到CMS在最好的情况下的延迟停顿，但是最差情况要好很多。

### G1垃圾回收器垃圾回收过程

![](https://s3.jpg.cm/2020/10/08/tloFw.png)

- 引用程序分配内存，**当年轻代的Eden区用尽时开始年轻代回收过程**：G1的年轻代收集阶段是一个**并行**的**独占式**收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后**从年轻代区间移动存活对象到Survivor取件或者老年区间，也有可能是两个区间都会涉及**。
- 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。
- 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了**。同时，这个老年代Region是和年轻代一起被回收的
- G1回收过程：年轻代GC
  - JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
  - 年轻代垃圾回收只会回收Eden区和Survivor区
  - YGC时，首先G1停止应用程序的执行（STW）,G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。
  - ![](https://s3.jpg.cm/2020/10/08/t6QP2.png)
- G1回收过程二：并发标记过程
  - ![](https://s3.jpg.cm/2020/10/08/t6duH.png)
- G1回收过程三：混合回收
  - ![](https://s3.jpg.cm/2020/10/08/t68kO.png)
  - ![](https://s3.jpg.cm/2020/10/08/t6A9w.png)

### 分区Region：化整为零

- 使用G1收集器时，他将整个Java堆划分成越2048个大小相同的独立Regin块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。**所有的Region大小相同，且在JVM生命周期内不会被改变**。

- 虽然保留新生代和老年代的概念，单新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

- ![](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20201008170311339.png)

- 一个Region有可能属于Eden，Survior或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E标识该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的标识未使用的内存区域。

- G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。

- 设置H的原因：

  对于堆中的大对象，默认直接会被分配到老年代，但是如果他是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，他专门用来存放大对象。**如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。**为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看